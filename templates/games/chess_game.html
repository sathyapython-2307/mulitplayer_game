{% extends 'base.html' %}
{% block title %}Chess Game{% endblock %}
{% block extra_css %}
<style>
    /* Chess Board Container */
    .chess-container {
        perspective: 1000px;
    }
    
    .chess-board { 
        display: grid; 
        grid-template-columns: repeat(8, 1fr); 
        max-width: 520px; 
        margin: 0 auto;
        border: 6px solid var(--teal-dark);
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2), inset 0 0 20px rgba(0,0,0,0.1);
    }
    
    /* Chess Squares */
    .chess-square { 
        aspect-ratio: 1; 
        display: flex; 
        align-items: center; 
        justify-content: center;
        position: relative;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    
    .chess-square.light { 
        background: linear-gradient(135deg, #f5e6d3 0%, #e8d5c4 100%); 
    }
    
    .chess-square.dark { 
        background: linear-gradient(135deg, #b58863 0%, #9e7555 100%); 
    }
    
    .chess-square:hover:not(.empty) { 
        filter: brightness(1.1);
    }
    
    .chess-square.selected { 
        background: linear-gradient(135deg, #7fc97f 0%, #5cb85c 100%) !important; 
        box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
    }
    
    .chess-square.last-move {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%) !important;
    }
    
    .chess-square.valid-move::after { 
        content: ''; 
        width: 30%;
        height: 30%;
        background: rgba(0,0,0,0.15); 
        border-radius: 50%;
        position: absolute;
        animation: pulse-dot 1.5s infinite;
    }
    
    .chess-square.can-capture::after {
        width: 90%;
        height: 90%;
        background: transparent;
        border: 4px solid rgba(220, 53, 69, 0.5);
        border-radius: 50%;
    }
    
    @keyframes pulse-dot {
        0%, 100% { transform: scale(1); opacity: 0.6; }
        50% { transform: scale(1.2); opacity: 0.3; }
    }
    
    /* Chess Pieces */
    .piece { 
        font-size: 3rem;
        line-height: 1;
        user-select: none; 
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        transition: transform 0.15s ease, filter 0.15s ease;
        cursor: grab;
        filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
    }
    
    .piece.white-piece {
        color: #fff;
        text-shadow: 1px 1px 0 #333, 2px 2px 4px rgba(0,0,0,0.4);
    }
    
    .piece.black-piece {
        color: #1a1a1a;
        text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
    }
    
    .chess-square:hover .piece {
        transform: scale(1.1);
    }
    
    .chess-square.selected .piece {
        transform: scale(1.15);
        filter: drop-shadow(0 0 8px rgba(255,255,255,0.8));
        animation: piece-selected 0.5s ease infinite alternate;
    }
    
    @keyframes piece-selected {
        from { transform: scale(1.1) translateY(0); }
        to { transform: scale(1.15) translateY(-3px); }
    }
    
    /* Move Animation */
    .piece.moving {
        animation: piece-move 0.3s ease-out;
    }
    
    @keyframes piece-move {
        0% { transform: scale(1.2); }
        50% { transform: scale(1.3); }
        100% { transform: scale(1); }
    }
    
    /* Turn Indicator */
    .turn-indicator { 
        padding: 18px 25px; 
        border-radius: 12px; 
        margin-bottom: 20px; 
        text-align: center;
        transition: all 0.3s ease;
    }
    
    .turn-indicator.your-turn { 
        background: linear-gradient(135deg, var(--teal-primary), var(--teal-secondary)); 
        color: white;
        box-shadow: 0 4px 15px rgba(13, 148, 136, 0.4);
        animation: glow-turn 2s ease-in-out infinite alternate;
    }
    
    @keyframes glow-turn {
        from { box-shadow: 0 4px 15px rgba(13, 148, 136, 0.4); }
        to { box-shadow: 0 4px 25px rgba(13, 148, 136, 0.6); }
    }
    
    .turn-indicator.waiting { 
        background: var(--teal-bg); 
        color: var(--teal-text);
    }
    
    .turn-indicator.bot-thinking {
        background: linear-gradient(135deg, #9333ea, #c026d3);
        color: white;
        animation: thinking-pulse 1s ease-in-out infinite;
    }
    
    @keyframes thinking-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    /* Player Info Cards */
    .player-info { 
        background: var(--teal-card); 
        padding: 15px; 
        border-radius: 12px; 
        margin-bottom: 15px;
        border: 2px solid transparent;
        transition: all 0.3s ease;
    }
    
    .player-info.active-player {
        border-color: var(--teal-primary);
        box-shadow: 0 0 15px rgba(13, 148, 136, 0.3);
    }
    
    .player-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
    }
    
    .player-avatar.white-avatar { background: #f5f5f5; color: #333; }
    .player-avatar.black-avatar { background: #333; color: #fff; }
    
    /* Bot Badge */
    .bot-badge { 
        background: linear-gradient(135deg, #9333ea, #c026d3); 
        color: white; 
        padding: 6px 16px; 
        border-radius: 20px; 
        font-size: 0.85rem;
        display: inline-flex;
        align-items: center;
        gap: 5px;
    }
    
    /* Captured Pieces */
    .captured-pieces {
        min-height: 30px;
        display: flex;
        flex-wrap: wrap;
        gap: 2px;
        font-size: 1.2rem;
        opacity: 0.7;
    }
    
    /* Promotion Modal */
    .promotion-btn {
        width: 70px;
        height: 70px;
        border: 2px solid var(--teal-primary);
        border-radius: 12px;
        background: var(--teal-bg);
        transition: all 0.2s ease;
    }
    
    .promotion-btn:hover {
        background: var(--teal-primary);
        transform: scale(1.1);
    }
    
    .promotion-piece {
        font-size: 2.5rem;
        line-height: 1;
    }
    
    /* Responsive */
    @media (max-width: 576px) {
        .piece { font-size: 2rem; }
        .chess-board { max-width: 100%; border-width: 4px; }
        .turn-indicator { padding: 12px 15px; }
        .promotion-btn { width: 55px; height: 55px; }
        .promotion-piece { font-size: 2rem; }
    }
    
    @media (min-width: 768px) {
        .piece { font-size: 3.2rem; }
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-lg-8 mx-auto">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                <div>
                    <h5 class="mb-0"><i class="bi bi-chess-queen"></i> Chess Game</h5>
                    <small class="text-white-50">Code: <strong>{{ game.code }}</strong></small>
                </div>
                <div class="d-flex align-items-center gap-2">
                    {% if game.is_bot_game %}
                    <span class="bot-badge"><i class="bi bi-robot"></i> vs AI</span>
                    {% endif %}
                    <button class="btn btn-outline-light btn-sm" id="resign-btn">
                        <i class="bi bi-flag"></i> Resign
                    </button>
                </div>
            </div>
            <div class="card-body">
                <!-- Player Info - Top (Opponent) -->
                <div class="player-info d-flex align-items-center justify-content-between" id="opponent-info">
                    <div class="d-flex align-items-center gap-3">
                        <div class="player-avatar {% if player_color == 'white' %}black-avatar{% else %}white-avatar{% endif %}">
                            {% if game.is_bot_game and player_color == 'white' %}
                            ðŸ¤–
                            {% else %}
                            <i class="bi bi-person-fill"></i>
                            {% endif %}
                        </div>
                        <div>
                            <div class="fw-bold">
                                {% if player_color == 'white' %}
                                    {% if game.is_bot_game %}AI Bot{% elif game.black_player %}{{ game.black_player.username }}{% else %}Waiting...{% endif %}
                                {% else %}
                                    {% if game.white_player %}{{ game.white_player.username }}{% else %}Waiting...{% endif %}
                                {% endif %}
                            </div>
                            <small class="text-muted">{% if player_color == 'white' %}Black{% else %}White{% endif %}</small>
                        </div>
                    </div>
                    <div class="captured-pieces" id="opponent-captured"></div>
                </div>
                
                <!-- Turn Indicator -->
                <div class="turn-indicator" id="turn-indicator">
                    <h6 class="mb-0" id="turn-text">
                        <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                        Loading game...
                    </h6>
                </div>
                
                <!-- Chess Board -->
                <div class="chess-container">
                    <div class="chess-board" id="chess-board"></div>
                </div>
                
                <!-- Player Info - Bottom (You) -->
                <div class="player-info d-flex align-items-center justify-content-between mt-3" id="player-info">
                    <div class="d-flex align-items-center gap-3">
                        <div class="player-avatar {% if player_color == 'white' %}white-avatar{% else %}black-avatar{% endif %}">
                            <i class="bi bi-person-fill"></i>
                        </div>
                        <div>
                            <div class="fw-bold">{{ user.username }} <span class="badge bg-success">You</span></div>
                            <small class="text-muted">{{ player_color|title }}</small>
                        </div>
                    </div>
                    <div class="captured-pieces" id="player-captured"></div>
                </div>
                
                <!-- Move History -->
                <div class="mt-3 text-center">
                    <small class="text-muted">
                        Moves: <span id="move-count">0</span>
                    </small>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Pawn Promotion Modal -->
<div class="modal fade" id="promotionModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered modal-sm">
        <div class="modal-content">
            <div class="modal-header" style="background: linear-gradient(135deg, var(--teal-primary), var(--teal-secondary)); color: white;">
                <h5 class="modal-title"><i class="bi bi-arrow-up-circle"></i> Promote Pawn</h5>
            </div>
            <div class="modal-body text-center py-4">
                <p class="mb-3">Choose a piece for promotion:</p>
                <div class="d-flex justify-content-center gap-2 flex-wrap" id="promotion-choices">
                    <button class="btn btn-lg promotion-btn" data-piece="q" title="Queen">
                        <span class="promotion-piece">â™•</span>
                    </button>
                    <button class="btn btn-lg promotion-btn" data-piece="r" title="Rook">
                        <span class="promotion-piece">â™–</span>
                    </button>
                    <button class="btn btn-lg promotion-btn" data-piece="b" title="Bishop">
                        <span class="promotion-piece">â™—</span>
                    </button>
                    <button class="btn btn-lg promotion-btn" data-piece="n" title="Knight">
                        <span class="promotion-piece">â™˜</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Game Over Modal -->
<div class="modal fade" id="gameOverModal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header" style="background: linear-gradient(135deg, var(--teal-primary), var(--teal-secondary)); color: white;">
                <h5 class="modal-title"><i class="bi bi-trophy"></i> Game Over</h5>
            </div>
            <div class="modal-body text-center py-5">
                <div id="winner-icon" class="display-1 mb-3"></div>
                <h3 id="winner-text"></h3>
                <p id="reason-text" class="text-muted mb-0"></p>
            </div>
            <div class="modal-footer justify-content-center border-0 pt-0">
                <a href="{% url 'chess_lobby' %}" class="btn btn-outline-secondary">
                    <i class="bi bi-arrow-left"></i> Lobby
                </a>
                <a href="{% url 'chess_matchmaking' %}" class="btn btn-warm">
                    <i class="bi bi-people"></i> vs Player
                </a>
                <a href="{% url 'chess_vs_bot' %}" class="btn btn-outline-warm">
                    <i class="bi bi-robot"></i> vs Bot
                </a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
const gameCode = '{{ game.code }}';
const myColor = '{{ player_color|default:"" }}';
const isBotGame = {{ game.is_bot_game|yesno:"true,false" }};

let socket = null;
let boardState = {};
let currentTurn = 'white';
let selectedSquare = null;
let lastMove = null;
let gameStatus = 'playing';
let moveCount = 0;
let botThinking = false;
let pendingPromotion = null; // {from, to} for pending promotion move

// Unicode chess pieces with better rendering
const pieceSymbols = {
    'wp': 'â™™', 'wn': 'â™˜', 'wb': 'â™—', 'wr': 'â™–', 'wq': 'â™•', 'wk': 'â™”',
    'bp': 'â™Ÿ', 'bn': 'â™ž', 'bb': 'â™', 'br': 'â™œ', 'bq': 'â™›', 'bk': 'â™š'
};

function connectWebSocket() {
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    socket = new WebSocket(`${wsScheme}://${window.location.host}/ws/chess/game/${gameCode}/`);
    
    socket.onopen = () => console.log('Connected to game');
    
    socket.onmessage = (e) => {
        const data = JSON.parse(e.data);
        
        switch(data.type) {
            case 'game_state':
                boardState = data.board_state;
                currentTurn = data.current_turn;
                gameStatus = data.status || 'playing';
                renderBoard();
                updateTurnIndicator();
                updatePlayerHighlight();
                break;
                
            case 'game_update':
                lastMove = data.move;
                boardState = data.board_state;
                currentTurn = data.current_turn;
                moveCount++;
                document.getElementById('move-count').textContent = moveCount;
                botThinking = false;
                renderBoard(true);
                updateTurnIndicator();
                updatePlayerHighlight();
                break;
                
            case 'bot_thinking':
                botThinking = data.thinking;
                updateTurnIndicator();
                break;
                
            case 'check':
                showCheckNotification(data.color);
                break;
                
            case 'game_over':
                gameStatus = data.status || 'finished';
                botThinking = false;
                showGameOver(data.status, data.winner, data.reason);
                break;
                
            case 'error':
                console.error('Game error:', data.message);
                break;
        }
    };
    
    socket.onclose = () => {
        console.log('Disconnected, reconnecting...');
        setTimeout(connectWebSocket, 2000);
    };
}

function renderBoard(animate = false) {
    const board = document.getElementById('chess-board');
    board.innerHTML = '';
    
    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
    const ranks = myColor === 'black' ? [1,2,3,4,5,6,7,8] : [8,7,6,5,4,3,2,1];
    const displayFiles = myColor === 'black' ? [...files].reverse() : files;
    
    ranks.forEach((rank, rIdx) => {
        displayFiles.forEach((file, fIdx) => {
            const square = `${file}${rank}`;
            const isLight = (rIdx + fIdx) % 2 === 0;
            const div = document.createElement('div');
            div.className = `chess-square ${isLight ? 'light' : 'dark'}`;
            div.dataset.square = square;
            
            // Highlight selected square
            if (selectedSquare === square) {
                div.classList.add('selected');
            }
            
            // Highlight last move
            if (lastMove && (lastMove.from === square || lastMove.to === square)) {
                div.classList.add('last-move');
            }
            
            // Add piece if present
            if (boardState[square]) {
                const piece = document.createElement('span');
                piece.className = `piece ${boardState[square][0] === 'w' ? 'white-piece' : 'black-piece'}`;
                piece.textContent = pieceSymbols[boardState[square]] || '?';
                
                // Animate moved piece
                if (animate && lastMove && lastMove.to === square) {
                    piece.classList.add('moving');
                }
                
                div.appendChild(piece);
            } else {
                div.classList.add('empty');
            }
            
            div.addEventListener('click', () => handleSquareClick(square));
            board.appendChild(div);
        });
    });
}

function handleSquareClick(square) {
    if (currentTurn !== myColor || gameStatus !== 'playing' || botThinking) {
        return;
    }
    
    if (selectedSquare) {
        if (square === selectedSquare) {
            clearSelection();
            return;
        }
        
        // Select different own piece
        if (boardState[square] && boardState[square][0] === myColor[0]) {
            clearSelection();
            selectedSquare = square;
            renderBoard();
            return;
        }
        
        // Check for pawn promotion
        const piece = boardState[selectedSquare];
        const isPromotion = isPawnPromotion(selectedSquare, square, piece);
        
        if (isPromotion) {
            // Show promotion modal
            pendingPromotion = { from: selectedSquare, to: square };
            showPromotionModal();
            clearSelection();
            return;
        }
        
        // Make regular move
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                type: 'move',
                from: selectedSquare,
                to: square
            }));
        }
        clearSelection();
    } else {
        // Select own piece
        if (boardState[square] && boardState[square][0] === myColor[0]) {
            selectedSquare = square;
            renderBoard();
        }
    }
}

function clearSelection() {
    selectedSquare = null;
    renderBoard();
}

function updateTurnIndicator() {
    const indicator = document.getElementById('turn-indicator');
    const text = document.getElementById('turn-text');
    
    if (gameStatus !== 'playing') {
        indicator.className = 'turn-indicator waiting';
        text.innerHTML = '<i class="bi bi-flag-fill me-2"></i>Game ended';
        return;
    }
    
    if (botThinking) {
        indicator.className = 'turn-indicator bot-thinking';
        text.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>AI is thinking...';
        return;
    }
    
    if (currentTurn === myColor) {
        indicator.className = 'turn-indicator your-turn';
        text.innerHTML = '<i class="bi bi-hand-index-fill me-2"></i>Your Turn!';
    } else {
        indicator.className = 'turn-indicator waiting';
        if (isBotGame) {
            text.innerHTML = '<i class="bi bi-robot me-2"></i>Bot\'s turn...';
        } else {
            text.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Opponent\'s turn...';
        }
    }
}

function updatePlayerHighlight() {
    const playerInfo = document.getElementById('player-info');
    const opponentInfo = document.getElementById('opponent-info');
    
    if (currentTurn === myColor) {
        playerInfo.classList.add('active-player');
        opponentInfo.classList.remove('active-player');
    } else {
        playerInfo.classList.remove('active-player');
        opponentInfo.classList.add('active-player');
    }
}

function showCheckNotification(color) {
    // Show brief check notification
    const indicator = document.getElementById('turn-indicator');
    const originalClass = indicator.className;
    indicator.className = 'turn-indicator your-turn';
    indicator.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i><strong>CHECK!</strong>';
    
    setTimeout(() => {
        indicator.className = originalClass;
        updateTurnIndicator();
    }, 2000);
}

function showGameOver(status, winner, reason) {
    gameStatus = status || 'finished';
    const modal = new bootstrap.Modal(document.getElementById('gameOverModal'));
    const winnerIcon = document.getElementById('winner-icon');
    const winnerText = document.getElementById('winner-text');
    const reasonText = document.getElementById('reason-text');
    
    // Determine outcome
    if (status === 'checkmate') {
        if (winner === myColor) {
            winnerIcon.textContent = 'ðŸ‘‘';
            winnerText.textContent = 'Checkmate - You Win!';
            winnerText.className = 'text-success';
        } else {
            winnerIcon.textContent = 'ðŸ’”';
            winnerText.textContent = 'Checkmate - You Lose';
            winnerText.className = 'text-danger';
        }
        reasonText.textContent = reason || 'Checkmate';
    } else if (status === 'stalemate') {
        winnerIcon.textContent = 'ðŸ¤';
        winnerText.textContent = 'Stalemate - Draw';
        winnerText.className = 'text-warning';
        reasonText.textContent = reason || 'No legal moves available';
    } else if (status === 'draw') {
        winnerIcon.textContent = 'ðŸ¤';
        winnerText.textContent = 'Draw';
        winnerText.className = 'text-warning';
        reasonText.textContent = reason || 'Game drawn';
    } else if (reason === 'resignation') {
        if (winner === myColor) {
            winnerIcon.textContent = 'ðŸŽ‰';
            winnerText.textContent = 'Victory!';
            winnerText.className = 'text-success';
        } else {
            winnerIcon.textContent = 'ðŸ˜”';
            winnerText.textContent = 'Defeat';
            winnerText.className = 'text-danger';
        }
        reasonText.textContent = winner === myColor ? 'Opponent resigned' : 'You resigned';
    }
    
    // Disable further moves
    updateTurnIndicator();
    modal.show();
}

// Resign button
document.getElementById('resign-btn').addEventListener('click', () => {
    if (gameStatus !== 'playing') return;
    
    if (confirm('Are you sure you want to resign?')) {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'resign' }));
        }
    }
});

// Pawn Promotion Functions
function isPawnPromotion(from, to, piece) {
    if (!piece || piece[1] !== 'p') return false;
    const toRank = parseInt(to[1]);
    const color = piece[0];
    // White pawn reaching rank 8, or black pawn reaching rank 1
    return (color === 'w' && toRank === 8) || (color === 'b' && toRank === 1);
}

function showPromotionModal() {
    const modal = new bootstrap.Modal(document.getElementById('promotionModal'));
    // Update piece colors based on player color
    const isWhite = myColor === 'white';
    const pieces = {
        'q': isWhite ? 'â™•' : 'â™›',
        'r': isWhite ? 'â™–' : 'â™œ',
        'b': isWhite ? 'â™—' : 'â™',
        'n': isWhite ? 'â™˜' : 'â™ž'
    };
    document.querySelectorAll('.promotion-btn').forEach(btn => {
        const pieceType = btn.dataset.piece;
        btn.querySelector('.promotion-piece').textContent = pieces[pieceType];
    });
    modal.show();
}

// Promotion button click handlers
document.querySelectorAll('.promotion-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        if (!pendingPromotion) return;
        
        const promoteTo = btn.dataset.piece;
        
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                type: 'move',
                from: pendingPromotion.from,
                to: pendingPromotion.to,
                promotion: promoteTo
            }));
        }
        
        pendingPromotion = null;
        bootstrap.Modal.getInstance(document.getElementById('promotionModal')).hide();
    });
});

// Initialize
connectWebSocket();
</script>
{% endblock %}
